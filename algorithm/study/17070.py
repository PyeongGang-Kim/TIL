import sys
'''
파이프 방향 ㅡ ㅣ \ 세가지를 0, 1, 2라 할 때
현재 0 방향이면 0, 2
1이면 1, 2
2이면 0, 1, 2

dfs로 하면 시간초과가 난다.
dp를 활용


현 위치로 들어오려면 현 위치에 장애물이 없어야 한다.

각 방향에 대해서 현 위치로 들어 올 수 있는 경우의 수를 확인한다.
왼쪽에서 들어올 수 있는 경우의 수는
왼쪽 위치의 왼쪽방향에서 들어온 경우, 대각선방향에서 들어온 경우이다.

위쪽에서 들어올 수 있는 경우의 수는
위쪽 위치의 위쪽방향에서 들어온 경우, 대각선방향에서 들어온 경우이다.

대각에서 들어올 수 있는 경우의 수는
왼쪽위쪽의 위치를 위쪽에서 들어온 경우, 대각선방향에서 들어온 경우, 왼쪽에서 들어온 경우이다.
단 대각으로 들어올 수 있으려면 i-1, j와 i, j-1또한 장애물이 없어야 한다.

마지막 행까지 반복한다.

'''

N = int(sys.stdin.readline())
nl = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
vl = [[[0, 0, 0] for _ in range(N)] for _ in range(N)]
vl[0][1][0] = 1
for i in range(2, N):
    if nl[0][i]:
        break
    vl[0][i][0] = 1
for j in range(1, N):
    for i in range(1, N):
        if not nl[j][i]:
            # 왼쪽에서 현 위치로 들어 올 경우
            vl[j][i][0] += vl[j][i-1][0] + vl[j][i-1][2]
            # 위쪽에서 현 위치로 들어 올 경우
            vl[j][i][1] += vl[j-1][i][1] + vl[j-1][i][2]
            # 대각에서 현 위치로 들어 올 경우
            if not nl[j][i-1] and not nl[j-1][i]:
                vl[j][i][2] += vl[j-1][i-1][0] + vl[j-1][i-1][1] + vl[j-1][i-1][2]

print(sum(vl[-1][-1]))